//
//  SBUMessageThreadModule.Input.swift
//  SendbirdUIKit
//
//  Created by Tez Park on 2022/11/07.
//  Copyright Â© 2022 Sendbird, Inc. All rights reserved.
//

import UIKit
import PhotosUI
import SendbirdChatSDK

/// Event methods for the views updates and performing actions from the input component in the message thread.
public protocol SBUMessageThreadModuleInputDelegate: SBUBaseChannelModuleInputDelegate {
    /// Called when a file was picked to send a file message.
    /// - Parameters:
    ///   - inputComponent: `SBUMessageThreadModule.Input` object.
    ///   - fileData: A data of a picked file.
    ///   - mimeType: A MIME type of a picked file.
    ///   - parentMessage: A message that will be a parent message. Please refer to *quote reply* features.
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        didPickFileData fileData: Data?,
        fileName: String,
        mimeType: String,
        parentMessage: BaseMessage?
    )
    
    /// Called when the send button was tapped.
    /// - Parameters:
    ///    - inputComponent: `SBUMessageThreadModule.Input` object.
    ///    - text: The normal text.
    ///    - mentionedMessageTemplate: The mentioned text that is generated by `text` and `mentionUsers`.
    ///    - mentionedUserIds: The mentioned userIds.
    ///    - parentMessage: A message that will be a parent message. Please refer to *quote reply* features.
    /// ```swift
    /// print(text) // "Hi @Nickname"
    /// print(mentionedMessageTemplate) // "Hi @{UserID}"
    /// print(mentionedUserIds) // ["{UserID}"]
    /// ```
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        didTapSend text: String,
        mentionedMessageTemplate: String,
        mentionedUserIds: [String],
        parentMessage: BaseMessage?
    )
    
    /// Called when the edit button was tapped.
    /// - Parameters:
    ///    - inputComponent: `SBUMessageThreadModule.Input` object.
    ///    - text: The normal text
    ///    - mentionedMessageTemplate: The mentioned text that is generated by `text` and `mentionUsers`.
    ///    - mentionedUserIds: The mentioned userIds.
    /// ```swift
    /// print(text) // "Hi @Nickname"
    /// print(mentionedMessageTemplate) // "Hi @{UserID}"
    /// print(mentionedUserIds) // ["{UserID}"]
    /// ```
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        didTapEdit text: String,
        mentionedMessageTemplate: String,
        mentionedUserIds: [String]
    )
    
    /// Called when the `SBUMessageInputMode` will be changed.
    /// - Parameters:
    ///    - inputComponent: `SBUMessageThreadModule.Input` object.
    ///    - mode: `SBUMessageInputMode` value.
    ///    - mentionedMessageTemplate: The mentioned text that is generated by `mentionUsers`.
    ///    - mentionedUserIds: The mentioned userIds.
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        willChangeMode mode: SBUMessageInputMode,
        message: BaseMessage?,
        mentionedMessageTemplate: String,
        mentionedUserIds: [String]
    )
    
    /// Called when the suggested mentions should be loaded. Please refer to `loadSuggestedMentions(with:)` function in `SBUGroupChannelViewModel`.
    /// - Parameters:
    ///   - inputComponent: `SBUMessageThreadModule.Input` object.
    ///   - filterText: The text that is used as a filter while loading the suggested mentions.
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        shouldLoadSuggestedMentions filterText: String
    )
    
    /// Called when it the suggested mentions are no longer valid.
    /// - Parameter inputComponent: `SBUMessageThreadModule.Input` object.
    func messageThreadModuleShouldStopSuggestingMention(
        _ inputComponent: SBUMessageThreadModule.Input
    )
    
    /// Called when it the voice message button tabbed.
    /// - Parameter inputComponent: `SBUMessageThreadModule.Input` object.
    func messageThreadModuleDidTapVoiceMessage(_ inputComponent: SBUMessageThreadModule.Input)
    
    /// Called when multiple files were picked to send a multiple files message.
    /// - Parameters:
    ///   - inputComponent: `SBUMessageThreadModule.Input` object.
    ///   - fileInfoList: A list of `UploadableFileInfo` for the picked files.
    ///   - parentMessage: A message that will be a parent message. Please refer to *quote reply* features.
    /// - Note: This interface is beta. We do not gaurantee this interface to work properly yet.
    /// - Since: [NEXT_VERSION_MFM_THREAD]
    func messageThreadModule(
        _ inputComponent: SBUMessageThreadModule.Input,
        didPickMultipleFiles fileInfoList: [UploadableFileInfo],
        parentMessage: BaseMessage
    )
}

/// Methods to get data source for the input component in the group channel.
public protocol SBUMessageThreadModuleInputDataSource: SBUBaseChannelModuleInputDataSource { }

extension SBUMessageThreadModule {
    /// A module component that represent the list of `SBUMessageThreadModule`.
    /// - Since: 3.3.0
    @objc(SBUMessageThreadModuleInput)
    @objcMembers
    open class Input: SBUBaseChannelModule.Input, SBUMentionManagerDelegate, SBUSuggestedMentionListDelegate {
        
        // MARK: - Logic properties (Public)

        public var suggestedMentionList: SBUSuggestedMentionList?
        
        /// The group channel object casted from `baseChannel`.
        public var channel: GroupChannel? {
            self.baseChannel as? GroupChannel
        }
        
        /// The object that acts as the delegate of the input component. The delegate must adopt the `SBUMessageThreadModuleInputDelegate`.
        public weak var delegate: SBUMessageThreadModuleInputDelegate? {
            get { self.baseDelegate as? SBUMessageThreadModuleInputDelegate }
            set { self.baseDelegate = newValue }
        }
        
        /// The object that acts as the data source of the input component. The data source must adopt the `SBUMessageThreadModuleInputDataSource`.
        public weak var dataSource: SBUMessageThreadModuleInputDataSource? {
            get { self.baseDataSource as? SBUMessageThreadModuleInputDataSource }
            set { self.baseDataSource = newValue }
        }
        
        /// The object that acts as the data source of the mention manager. The data source must adopt the `SBUMentionManagerDataSource`.
        public weak var mentionManagerDataSource: SBUMentionManagerDataSource?
        
        public var parentMessage: BaseMessage?
        
        public var mentionManager: SBUMentionManager?
        
        // MARK: - Logic Properties (Private)
        
        /// String constants used when sending a multiple files message.
        /// - Since: [NEXT_VERSION_MFM_THREAD]
        struct MultipleFilesConstants {
            static let fileInfoList = "uploadableFileInfoList"
            static let image = "image"
            static let gif = "gif"
            static let video = "video"
        }
        
        /// The OperationQueue that gaurantees the order of messages when sending.
        lazy var messageOperationQueue: OperationQueue = {
            let operationQueue = OperationQueue()
            operationQueue.name = SBUConstant.messageOperationQueueName
            operationQueue.maxConcurrentOperationCount = 1
            return operationQueue
        }()
        
        private lazy var defaultMessageInputView: SBUMessageInputView = {
            let messageInputView = SBUModuleSet.MessageThreadModule.InputComponent.MessageInputView.init(isThreadMessage: true)
            messageInputView.delegate = self
            messageInputView.datasource = self
            return messageInputView
        }()
        
        // MARK: - LifeCycle
        
        /// Configures component with parameters.
        /// - Parameters:
        ///   - delegate: `SBUMessageThreadModuleListDelegate` type listener
        ///   - dataSource: The data source that is type of `SBUMessageThreadModuleInputDataSource`
        ///   - theme: `SBUChannelTheme` object
        open func configure(
            delegate: SBUMessageThreadModuleInputDelegate,
            dataSource: SBUMessageThreadModuleInputDataSource,
            parentMessage: BaseMessage?,
            mentionManagerDataSource: SBUMentionManagerDataSource? = nil,
            theme: SBUChannelTheme
        ) {
            self.delegate = delegate
            self.dataSource = dataSource
            self.parentMessage = parentMessage
            self.mentionManagerDataSource = mentionManagerDataSource
            self.theme = theme
            
            self.setupViews()
            self.setupLayouts()
            self.setupStyles()
            
            if SendbirdUI.config.groupChannel.channel.isMentionEnabled {
                self.setupMentionManager()
            }
        }
        
        open override func setupViews() {
            // NOTE: Input entireContnet interface has been temporarily closed.
//            #if SWIFTUI
//            if self.applyViewConverter(.entireContent) { return }
//            #endif
            
            /// It does not call `super.setupViews()` because it creates `messageInputView` differently for each channelType
            
            if self.messageInputView == nil {
                self.messageInputView = defaultMessageInputView
            }
            if let messageInputView = messageInputView {
                inputVStackView.setVStack([
                    messageInputView
                ])
                self.addSubview(inputVStackView)
            }
            
            self.updatePlaceholder()
        }
        
        open override func setupLayouts() {
            super.setupLayouts()
        }
        
        // MARK: - UIImagePickerController
        open override func pickImageFile(info: [UIImagePickerController.InfoKey: Any]) {
            var tempImageURL: URL?
            if let imageURL = info[.imageURL] as? URL {
                // file:///~~~
                tempImageURL = imageURL
            }
            
            guard let imageURL = tempImageURL else {
                let originalImage = info[.originalImage] as? UIImage
                // for Camera capture
                guard let image = originalImage?.fixedOrientation(),
                      let imageData = image.sbu_convertToData() else { return }
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: imageData,
                    fileName: "\(Date().sbu_toString(dateFormat: SBUDateFormatSet.Message.fileNameFormat, localizedFormat: false)).jpg",
                    mimeType: "image/jpeg",
                    parentMessage: self.parentMessage
                )
                return
            }
            
            let imageName = imageURL.lastPathComponent
            guard let mimeType = SBUUtils.getMimeType(url: imageURL) else {
                SBULog.error("Failed to get mimeType")
                return
            }
            
            switch mimeType {
            case "image/gif":
                let gifData = try? Data(contentsOf: imageURL)
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: gifData,
                    fileName: imageName,
                    mimeType: mimeType,
                    parentMessage: self.parentMessage
                )
            default:
                let originalImage = info[.originalImage] as? UIImage
                guard let image = originalImage?.fixedOrientation(),
                      let imageData = image.sbu_convertToData() else { return }
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: imageData,
                    fileName: imageName,
                    mimeType: mimeType,
                    parentMessage: self.parentMessage
                )
            }
        }
        
        open override func pickVideoFile(info: [UIImagePickerController.InfoKey: Any]) {
            do {
                guard let videoURL = info[.mediaURL] as? URL else { return }
                let videoFileData = try Data(contentsOf: videoURL)
                let videoName = videoURL.lastPathComponent
                guard let mimeType = SBUUtils.getMimeType(url: videoURL) else { return }
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: videoFileData,
                    fileName: videoName,
                    mimeType: mimeType,
                    parentMessage: self.parentMessage
                )
            } catch {
                SBULog.error(error.localizedDescription)
                let sbError = SBError(domain: (error as NSError).domain, code: (error as NSError).code)
                self.delegate?.didReceiveError(sbError, isBlocker: false)
            }
        }
        
        @available(iOS 14.0, *)
        open override func pickImageFile(itemProvider: NSItemProvider) {
            itemProvider.loadItem(forTypeIdentifier: UTType.image.identifier, options: [:]) { [weak self] url, _ in
                guard let self = self else { return }
                
                if itemProvider.canLoadObject(ofClass: UIImage.self) {
                    itemProvider.loadObject(ofClass: UIImage.self) { imageItem, _ in
                
                        DispatchQueue.main.async {
                            guard let originalImage = imageItem as? UIImage else { return }
                            guard let imageURL = url as? URL else { return }
                            guard let mimeType = SBUUtils.getMimeType(url: imageURL) else { return }
                            
                            guard let imageData = originalImage
                                .fixedOrientation()
                                .sbu_convertToData() else { return }
                            
                            let fileExtension = imageURL.pathExtension
                            let fileName = "\(Date().sbu_toString(dateFormat: SBUDateFormatSet.Message.fileNameFormat, localizedFormat: false)).\(fileExtension)"
                            
                            DispatchQueue.main.async { [self, imageData, mimeType, fileName] in
                                self.delegate?.messageThreadModule(
                                    self,
                                    didPickFileData: imageData,
                                    fileName: fileName,
                                    mimeType: mimeType,
                                    parentMessage: self.parentMessage
                                )
                            }
                        }
                    }
                }
            }
        }
        
        @available(iOS 14.0, *)
        open override func pickGIFFile(itemProvider: NSItemProvider) {
            itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.gif.identifier) { [weak self] url, _ in
                guard let self = self else { return }
                guard let imageURL = url else { return }
                guard let mimeType = SBUUtils.getMimeType(url: imageURL) else { return }
                
                let gifData = try? Data(contentsOf: imageURL)
                let fileExtension = imageURL.pathExtension
                let fileName = "\(Date().sbu_toString(dateFormat: SBUDateFormatSet.Message.fileNameFormat, localizedFormat: false)).\(fileExtension)"
                
                DispatchQueue.main.async { [self, gifData, mimeType, fileName] in
                    self.delegate?.messageThreadModule(
                        self,
                        didPickFileData: gifData,
                        fileName: fileName,
                        mimeType: mimeType,
                        parentMessage: self.parentMessage
                    )
                }
            }
        }
        
        @available(iOS 14.0, *)
        open override func pickVideoFile(itemProvider: NSItemProvider) {
            itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.movie.identifier) { [weak self] url, error in
                guard let videoURL = url else { return }
                guard let self = self else { return }
                do {
                    let videoFileData = try Data(contentsOf: videoURL)
                    let videoName = videoURL.lastPathComponent
                    guard let mimeType = SBUUtils.getMimeType(url: videoURL) else { return }
                    
                    DispatchQueue.main.async { [self, videoFileData, videoName, mimeType] in
                        self.delegate?.messageThreadModule(
                            self,
                            didPickFileData: videoFileData,
                            fileName: videoName,
                            mimeType: mimeType,
                            parentMessage: self.parentMessage
                        )
                    }
                } catch {
                    SBULog.error(error.localizedDescription)
                }
            }
        }
        
        open override func pickDocumentFile(documentURLs: [URL]) {
            do {
                guard let documentURL = documentURLs.first else { return }
                let documentData = try Data(contentsOf: documentURL)
                let documentName = documentURL.lastPathComponent
                guard let mimeType = SBUUtils.getMimeType(url: documentURL) else { return }
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: documentData,
                    fileName: documentName,
                    mimeType: mimeType,
                    parentMessage: self.parentMessage
                )
            } catch {
                SBULog.error(error.localizedDescription)
                let sbError = SBError(domain: (error as NSError).domain, code: (error as NSError).code)
                self.delegate?.didReceiveError(sbError, isBlocker: false)
            }
        }
        
        open override func pickImageData(_ data: Data, fileName: String? = nil, mimeType: String? = nil) {
            let tempFileName = "\(Date().sbu_toString(dateFormat: SBUDateFormatSet.Message.fileNameFormat, localizedFormat: false)).jpg"
            
            self.delegate?.messageThreadModule(
                self,
                didPickFileData: data,
                fileName: fileName ?? tempFileName,
                mimeType: mimeType ?? "image/jpeg",
                parentMessage: self.parentMessage
            )
        }
        
        open override func pickVideoURL(_ url: URL) {
            do {
                let videoFileData = try Data(contentsOf: url)
                let videoName = url.lastPathComponent
                guard let mimeType = SBUUtils.getMimeType(url: url) else { return }
                
                self.delegate?.messageThreadModule(
                    self,
                    didPickFileData: videoFileData,
                    fileName: videoName,
                    mimeType: mimeType,
                    parentMessage: self.parentMessage
                )
            } catch {
                SBULog.error(error.localizedDescription)
                let sbError = SBError(domain: (error as NSError).domain, code: (error as NSError).code)
                self.delegate?.didReceiveError(sbError, isBlocker: false)
            }
        }
        
        // MARK: - PHPickerViewController
        
        /// Loads image files from the NSItemProvider and sends a multiple files message.
        /// - Parameters:
        ///    - itemProviders: An array of NSItemProvider
        /// - Note: This interface is beta. We do not gaurantee this interface to work properly yet.
        /// - Since: [NEXT_VERSION_MFM_THREAD]
        @available(iOS 14.0, *)
        public func pickMultipleImageFiles(itemProviders: [NSItemProvider]) {
            // Define and add a blocking operation to the message queue.
            // This blocking operation will be executed after all images/gifs are finished loading.
            let operation = BlockingOperation(asyncTask: { operation in
                defer { operation.complete() }
                
                guard let fileInfoList = operation.userInfo[MultipleFilesConstants.fileInfoList] as? [UploadableFileInfo],
                      fileInfoList.isEmpty == false,
                      let parentMessage = self.parentMessage else {
                    
                    return
                }
                
                DispatchQueue.main.async { [self, fileInfoList] in
                    self.delegate?.messageThreadModule(
                        self,
                        didPickMultipleFiles: fileInfoList,
                        parentMessage: parentMessage
                    )
                }
            }, requireExplicity: true)
            
            messageOperationQueue.addOperation(operation)
            
            // Load images and GIFs.
            var fileInfoList: [UploadableFileInfo?] = Array(repeating: nil, count: itemProviders.count)
            let group = DispatchGroup()
            
            for (index, itemProvider) in itemProviders.enumerated() {
                group.enter()
                    // Image
                    if itemProvider.hasItemConformingToTypeIdentifier(UTType.image.identifier) {
                        self.loadImageFile(itemProvider: itemProvider, index: index) { imageData, fileName, mimeType in
                            defer {
                                group.leave()
                            }
                            
                            guard let imageData = imageData, let fileName = fileName, let mimeType = mimeType else {
                                return
                            }

                            // Create UploadableFileInfo.
                            let fileInfo = UploadableFileInfo(file: imageData)
                            fileInfo.mimeType = mimeType
                            fileInfo.fileName = fileName
                            
                            if let image = UIImage(data: imageData) {
                                let thumbnailSize = ThumbnailSize.make(maxSize: image.size)
                                fileInfo.thumbnailSizes = [thumbnailSize]
                            }

                            fileInfoList[index] = fileInfo
                        }
                    }

                    // GIF
                    else if itemProvider.hasItemConformingToTypeIdentifier(UTType.gif.identifier) {
                        self.loadGIFfile(itemProvider: itemProvider, index: index) { gifData, fileName, mimeType in
                            defer {
                                group.leave()
                            }
                            
                            guard let gifData = gifData, let fileName = fileName, let mimeType = mimeType else {
                                return
                            }
                            
                            // Create UploadableFileInfo.
                            let fileInfo = UploadableFileInfo(file: gifData)
                            fileInfo.mimeType = mimeType
                            fileInfo.fileName = fileName
                            
                            if let image = UIImage(data: gifData) {
                                let thumbnailSize = ThumbnailSize.make(maxSize: image.size)
                                fileInfo.thumbnailSizes = [thumbnailSize]
                            }
                            
                            fileInfoList[index] = fileInfo
                        }
                    }
            }
            
            // Finally, execute the blocking operation.
            group.notify(queue: .main) {
                operation.userInfo[MultipleFilesConstants.fileInfoList] = fileInfoList
                operation.markReady()
            }
        }
        
        // MARK: PHPicker utils
        
        /// Loads image data from a NSItemProvider.
        /// - Parameters:
        ///    - itemProvider: the NSItemProvider to load the image data from
        ///    - index: the index of the image file in a multiple files message. `nil` in a single file message
        ///    - completionHandler: returns image data, fileName, and mimeType
        /// - Note: This interface is beta. We do not gaurantee this interface to work properly yet.
        /// - Since: [NEXT_VERSION_MFM_THREAD]
        @available(iOS 14.0, *)
        public func loadImageFile(
            itemProvider: NSItemProvider,
            index: Int? = nil,
            completion: @escaping (Data?, String?, String?) -> Void
        ) {
            itemProvider.loadItem(forTypeIdentifier: UTType.image.identifier, options: [:]) { url, _ in
                guard let imageURL = url as? URL,
                      imageURL.isFileSizeUploadable else {
                    completion(nil, nil, nil)
                    return
                }
                
                if itemProvider.canLoadObject(ofClass: UIImage.self) {
                    itemProvider.loadObject(ofClass: UIImage.self) { imageItem, _ in
                        guard let originalImage = imageItem as? UIImage,
                              let mimeType = SBUUtils.getMimeType(url: imageURL),
                              let imageData = originalImage.fixedOrientation().sbu_convertToData() else {
                            completion(nil, nil, nil)
                            return
                        }

                        let fileExtension = imageURL.pathExtension
                        
                        /// If multiple files message, fileName is `date_index.fileExtension`
                        /// If single file message, fileName is `date.fileExtension`
                        var fileName = Date().sbu_toString(
                            dateFormat: SBUDateFormatSet.Message.fileNameFormat,
                            localizedFormat: false
                        )
                        if let index = index {
                            fileName = "\(fileName)_\(index)"
                        }
                        
                        fileName = "\(fileName).\(fileExtension)"
                        
                        completion(imageData, fileName, mimeType)
                    }
                } else {
                    completion(nil, nil, nil)
                }
            }
        }
        
        /// Loads GIF data from a NSItemProvider.
        /// - Parameters:
        ///    - itemProvider: the NSItemProvider to load the image data from
        ///    - index: the index of the image file in a multiple files message. `nil` in a single file message
        ///    - completionHandler: returns image data, fileName, and mimeType
        /// - Note: This interface is beta. We do not gaurantee this interface to work properly yet.
        /// - Since: [NEXT_VERSION_MFM_THREAD]
        @available(iOS 14.0, *)
        public func loadGIFfile(
            itemProvider: NSItemProvider,
            index: Int? = nil,
            completion: @escaping (Data?, String?, String?) -> Void
        ) {
            itemProvider.loadFileRepresentation(forTypeIdentifier: UTType.gif.identifier) { url, _ in
                guard let imageURL = url, imageURL.isFileSizeUploadable else {
                    completion(nil, nil, nil)
                    return
                }
                
                guard let mimeType = SBUUtils.getMimeType(url: imageURL) else {
                    completion(nil, nil, nil)
                    return
                }
                
                let gifData = try? Data(contentsOf: imageURL)
                let fileExtension = imageURL.pathExtension
                
                /// If multiple files message, fileName is `date_index.fileExtension`
                /// If single file message, fileName is `date.fileExtension`
                var fileName = Date().sbu_toString(
                    dateFormat: SBUDateFormatSet.Message.fileNameFormat,
                    localizedFormat: false
                )
                if let index = index {
                    fileName = "\(fileName)_\(index)"
                }
                
                fileName = "\(fileName).\(fileExtension)"
                
                completion(gifData, fileName, mimeType)
            }
        }
        
        // MARK: - Common: Update
        open override func updateMessageInputMode(_ mode: SBUMessageInputMode, message: BaseMessage? = nil) {
            self.updatePlaceholder()
                
            super.updateMessageInputMode(mode, message: message)
            if mode == .edit {
                guard SendbirdUI.config.groupChannel.channel.isMentionEnabled else { return }
                guard let messageInputView = self.messageInputView as? SBUMessageInputView else { return }
                guard let mentionedUsers = message?.mentionedUsers else { return }
                guard let mentionedMessageTemplate = message?.mentionedMessageTemplate,
                      mentionedMessageTemplate != "" else { return }
                
                messageInputView.isThreadMessage = false
                messageInputView.isThreadFirstMessage = false
                
                if let mentionManager = mentionManager {
                    mentionManager.reset()
                } else {
                    self.mentionManager = SBUMentionManager()
                    self.mentionManager?.configure(
                        delegate: self,
                        dataSource: self.mentionManagerDataSource,
                        defaultTextAttributes: messageInputView.defaultAttributes,
                        mentionTextAttributes: messageInputView.mentionedAttributes
                    )
                }
                
                let attributedText = self.mentionManager!.generateMentionedMessage(
                    with: mentionedMessageTemplate,
                    mentionedUsers: SBUUser.convertUsers(mentionedUsers)
                )
                messageInputView.textView?.attributedText = attributedText
            }
        }
        
        /// Updates state of `messageInputView`.
        open override func updateMessageInputModeState() {
            if channel != nil {
                self.updateBroadcastModeState()
                self.updateFrozenModeState()
                self.updateMutedModeState()
                self.updatePlaceholder()
            } else {
                if let messageInputView = self.messageInputView as? SBUMessageInputView {
                    messageInputView.setErrorState()
                }
            }
        }
        
        /// This is used to update frozen mode of `messageInputView`. This will call `SBUBaseChannelModuleInputDelegate baseChannelModule(_:didUpdateFrozenState:)`
        open override func updateFrozenModeState() {
            let isOperator = self.channel?.myRole == .operator
            let isBroadcast = self.channel?.isBroadcast ?? false
            let isFrozen = self.channel?.isFrozen ?? false
            if !isBroadcast {
                if let messageInputView = self.messageInputView as? SBUMessageInputView {
                    messageInputView.setFrozenModeState(!isOperator && isFrozen)
                }
            }
            self.delegate?.baseChannelModule(self, didUpdateFrozenState: isFrozen)
        }
        
        /// Updates the mode of `messageInputView` according to broadcast state of the channel.
        open func updateBroadcastModeState() {
            let isOperator = self.channel?.myRole == .operator
            let isBroadcast = self.channel?.isBroadcast ?? false
            self.messageInputView?.isHidden = !isOperator && isBroadcast
        }
        
        /// Updates the mode of `messageInputView` according to frozen and muted state of the channel.
        open func updateMutedModeState() {
            let isOperator = self.channel?.myRole == .operator
            let isFrozen = self.channel?.isFrozen ?? false
            let isMuted = self.channel?.myMutedState == .muted
            if !isFrozen || (isFrozen && isOperator) {
                if let messageInputView = self.messageInputView as? SBUMessageInputView {
                    messageInputView.setMutedModeState(isMuted)
                }
            }
        }
        
        /// Updates the placeholder text.
        open func updatePlaceholder() {
            let messageInputView = self.messageInputView as? SBUMessageInputView
            if (self.parentMessage?.threadInfo.replyCount ?? 0) > 0 {
                messageInputView?.isThreadMessage = true
                messageInputView?.isThreadFirstMessage = false
            } else {
                messageInputView?.isThreadMessage = false
                messageInputView?.isThreadFirstMessage = true
            }
            
            messageInputView?.updatePlaceholderText()
        }
        
        // MARK: - Mention
        
        /// Initializes `SBUMentionManager` instance and configure with attributes.
        /// The `messageInputView` updates to use its `defaultAttributes` and `mentionedAttributes`.
        open func setupMentionManager() {
            guard SendbirdUI.config.groupChannel.channel.isMentionEnabled else { return }
            
            if mentionManager == nil {
                self.mentionManager = SBUMentionManager()
            }
            
            guard let messageInputView = self.messageInputView as? SBUMessageInputView,
                  let mentionManager = self.mentionManager else { return }
            
            mentionManager.configure(
                delegate: self,
                dataSource: self.mentionManagerDataSource,
                defaultTextAttributes: messageInputView.defaultAttributes,
                mentionTextAttributes: messageInputView.mentionedAttributes
            )
            
            messageInputView.textView?.typingAttributes = mentionManager.defaultTextAttributes
            messageInputView.textView?.linkTextAttributes = mentionManager.mentionTextAttributes
        }
        
        /// Handles pending mention suggestion. This calls when the channel view model receives member list from callback.
        open func handlePendingMentionSuggestion(with members: [SBUUser]?) {
            self.mentionManager?.handlePendingMentionSuggestion()
        }
        
        /// Updates `suggestedMentionList` with `members`
        open func updateSuggestedMentionList(with members: [SBUUser]) {
            guard let config = SBUGlobals.userMentionConfig else {
                SBULog.error("`SBUGlobals.userMentionConfig` is `nil`")
                return
            }
            
            guard SendbirdUI.config.groupChannel.channel.isMentionEnabled else {
                SBULog.error("User mention features are disabled. See `SBUGlobals.isMentionEnabled` for more information")
                return
            }
            
            var filteredMembers = members.filter {
                ($0.user?.isActive == true) &&
                ($0.userId != SBUGlobals.currentUser?.userId)
            }
            
            if filteredMembers.count > config.suggestionLimit {
                // Remove buffer member
                filteredMembers.removeLast()
            }
            
            if self.suggestedMentionList?.superview == nil, filteredMembers.count > 0 {
                self.presentSuggestedMentionList()
            }
            guard let suggestedMentionList = suggestedMentionList else { return }

            let mentionLimit = SBUGlobals.userMentionConfig?.mentionLimit ?? 10
            if let mentionedList = mentionManager?.mentionedList, mentionedList.count < mentionLimit {
                suggestedMentionList.isLimitGuideEnabled = false
            } else {
                suggestedMentionList.isLimitGuideEnabled = true
            }
            suggestedMentionList.reloadData(with: filteredMembers)
            
            let height = CGFloat(44 * filteredMembers.count)
            let maxHeight: CGFloat
            switch UIDevice.current.orientation {
            case .landscapeRight, .landscapeLeft:
                maxHeight = 164
            default:
                maxHeight = 196
            }
            suggestedMentionList.heightConstraint?.constant = suggestedMentionList.isLimitGuideEnabled
            ? 44
            : min(height, maxHeight)
            
            self.layoutIfNeeded()
        }
        
        /// Presents `suggestedMentionList`
        open func presentSuggestedMentionList() {
            if suggestedMentionList == nil {
                self.suggestedMentionList = SBUSuggestedMentionList()
                self.suggestedMentionList?.delegate = self
            }
            
            guard let suggestedMentionList = suggestedMentionList else { return }
            guard let messageInputView = self.messageInputView else { return }
            
            self.addSubview(suggestedMentionList)
            
            suggestedMentionList.translatesAutoresizingMaskIntoConstraints = false
            suggestedMentionList.heightConstraint?.isActive = false
            suggestedMentionList.heightConstraint = suggestedMentionList.heightAnchor.constraint(equalToConstant: 0)
            
            suggestedMentionList
                .sbu_constraint(equalTo: self, leading: 0, trailing: 0)
                .sbu_constraint_equalTo(
                    bottomAnchor:
                        (messageInputView as? SBUMessageInputView)?.contentHStackView.topAnchor
                        ?? messageInputView.topAnchor,
                    bottom: 0
                )
                .sbu_constraint_lessThan(height: 196)

            suggestedMentionList.heightConstraint?.isActive = true
        }
        
        /// Dismiss `suggestedMentionList` and remove from super view.
        open func dismissSuggestedMentionList() {
            guard let suggestedMentionList = self.suggestedMentionList else { return }
            
            suggestedMentionList.reloadData(with: [])
            
            suggestedMentionList.removeFromSuperview()
            self.suggestedMentionList = nil
            self.setupLayouts()
        }
        
        open override func point(inside point: CGPoint, with event: UIEvent?) -> Bool {
            guard let suggestedMentionList = suggestedMentionList, suggestedMentionList.superview != nil else {
                return super.point(inside: point, with: event)
            }
            let tounchedInside = bounds
                .insetBy(dx: 0, dy: -suggestedMentionList.bounds.height)
                .contains(point)
            if !tounchedInside {
                self.dismissSuggestedMentionList()
            }
            return tounchedInside
        }
        
        // MARK: - SBUMessageInputViewDelegate
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            shouldChangeTextIn range: NSRange,
                                            replacementText text: String) -> Bool {
            guard let textView = messageInputView.textView else { return false }
            return self.mentionManager?.shouldChangeText(
                on: textView,
                in: range,
                replacementText: text
            ) ?? true
        }
        
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            shouldInteractWith url: URL,
                                            in characterRange: NSRange,
                                            interaction: UITextItemInteraction) -> Bool {
            // TODO: Mention tap action
            return true
        }
        
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            didChangeSelection range: NSRange) {
            guard let textView = messageInputView.textView else { return }
            guard let mentionManager = self.mentionManager else { return }

            guard !mentionManager.needToSkipSelection(textView) else { return }
            
            guard self.channel?.isBroadcast == false else { return }
            
            self.mentionManager?.handleMentionSuggestion(on: textView, range: range)
        }
        
        /// Called when the send button was selected.
        /// - Parameters:
        ///    - messageInputView: `SBUMessageinputView` object.
        ///    - text: The sent text.
        /// - NOTE: If there's mentions in `mentionManager.mentionedList`, It invokes ``messageInputView(_:didSelectSend:mentionManager:)`` instead.
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            didSelectSend text: String) {
            if let textView = messageInputView.textView,
                let mentionManager = mentionManager,
                mentionManager.mentionedList.isEmpty == false {
                self.messageInputView(
                    messageInputView,
                    didSelectSend: textView.attributedText,
                    mentionManager: mentionManager,
                    parentMessage: self.parentMessage
                )
            } else {
                guard text.count > 0 else { return }
                messageInputView.setMode(.none)
                
                self.baseDelegate?.baseChannelModule(
                    self,
                    didTapSend: text,
                    parentMessage: self.parentMessage
                )
            }
        }
        
        /// Called when the message input mode will be changed via `setMode(_:message:)` method.
        /// - Parameters:
        ///    - messageInputView: `SBUMessageinputView` object.
        ///    - mode: `SBUMessageInputMode` value. The `messageInputView` changes its mode to this value.
        ///    - message: `BaseMessage` object. It's `nil` when the `mode` is `none`.
        /// - NOTE: If there's mentions in `mentionManager.mentionedList`, It invokes ``messageInputView(_:willChangeMode:message:mentionManager:)`` instead.
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            willChangeMode mode: SBUMessageInputMode,
                                            message: BaseMessage?) {
            if let mentionManager = mentionManager,
                mentionManager.mentionedList.isEmpty == false {
                self.messageInputView(
                    messageInputView,
                    willChangeMode: mode,
                    message: message,
                    mentionManager: mentionManager
                )
            } else {
                super.messageInputView(messageInputView, willChangeMode: mode, message: message)
            }
        }
        
        /// Called when the message input mode will be changed via `setMode(_:message:)` method and need to reset the `mentionManager`.
        open func messageInputView(_ messageInputView: SBUMessageInputView,
                                   willChangeMode mode: SBUMessageInputMode,
                                   message: BaseMessage?,
                                   mentionManager: SBUMentionManager) {
            let mentionedMessageTemplate: String
            if let text = messageInputView.textView?.attributedText {
                mentionedMessageTemplate = mentionManager.generateTemplate(
                    with: text,
                    mentions: mentionManager.mentionedList
                )
            } else {
                mentionedMessageTemplate = ""
            }
            
            self.delegate?.messageThreadModule(
                self,
                willChangeMode: mode,
                message: message,
                mentionedMessageTemplate: mentionedMessageTemplate,
                mentionedUserIds: mentionManager.mentionedList.compactMap { $0.user.userId }
            )
            mentionManager.reset()
        }
        
        open func messageInputView(_ messageInputView: SBUMessageInputView,
                                   didSelectSend text: NSAttributedString,
                                   mentionManager: SBUMentionManager,
                                   parentMessage: BaseMessage?) {
            self.delegate?.messageThreadModule(
                self,
                didTapSend: text.string,
                mentionedMessageTemplate: mentionManager.generateTemplate(
                    with: text,
                    mentions: mentionManager.mentionedList
                ),
                mentionedUserIds: mentionManager.mentionedList.compactMap { $0.user.userId },
                parentMessage: self.parentMessage
            )
            messageInputView.setMode(.none)
            
            mentionManager.reset()
        }
        
        open override func messageInputView(_ messageInputView: SBUMessageInputView,
                                            didSelectEdit text: String) {
            if let textView = messageInputView.textView,
                let mentionManager = mentionManager,
                mentionManager.mentionedList.isEmpty == false {
                self.messageInputView(
                    messageInputView,
                    didSelectEdit: textView.attributedText,
                    mentionManager: mentionManager
                )
            } else {
                super.messageInputView(messageInputView, didSelectEdit: text)
            }
        }
        
        open func messageInputView(_ messageInputView: SBUMessageInputView,
                                   didSelectEdit text: NSAttributedString,
                                   mentionManager: SBUMentionManager) {
            self.delegate?.messageThreadModule(
                self,
                didTapEdit: text.string,
                mentionedMessageTemplate: mentionManager.generateTemplate(
                    with: text,
                    mentions: mentionManager.mentionedList
                ),
                mentionedUserIds: mentionManager.mentionedList.compactMap { $0.user.userId }
            )
            mentionManager.reset()
        }

        open override func messageInputViewDidTapVoiceMessage(_ messageInputView: SBUMessageInputView) {
            self.delegate?.messageThreadModuleDidTapVoiceMessage(self)
        }
        
        // MARK: - SBUMentionManagerDelegate
        open func mentionManager(_ manager: SBUMentionManager,
                                 didChangeSuggestedMention members: [SBUUser],
                                 filteredText: String?,
                                 isTriggered: Bool) {
            guard isTriggered else {
                self.dismissSuggestedMentionList()
                self.delegate?.messageThreadModuleShouldStopSuggestingMention(self)
                return
            }
            
            if self.suggestedMentionList?.superview == nil {
                self.presentSuggestedMentionList()
            }
            self.updateSuggestedMentionList(with: members)
        }
        
        open func mentionManager(_ manager: SBUMentionManager, didInsertMentionsTo textView: UITextView) {
            self.dismissSuggestedMentionList()
        }
        
        open func mentionManager(_ manager: SBUMentionManager, shouldLoadSuggestedMentions keyword: String) {
            self.delegate?.messageThreadModule(self, shouldLoadSuggestedMentions: keyword)
        }
        
        // MARK: - SBUSuggestedMentionListDelegate
        open func suggestedUserList(_ list: SBUSuggestedMentionList, didSelectUser user: SBUUser) {
            guard let textView = (self.messageInputView as? SBUMessageInputView)?.textView else { return }
            self.mentionManager?.addMention(at: textView, user: user)
        }
    }
}
