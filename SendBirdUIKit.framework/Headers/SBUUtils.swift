//
//  SBUUtils.swift
//  SendBirdUIKit
//
//  Created by Tez Park on 26/02/2020.
//  Copyright Â© 2020 SendBird, Inc. All rights reserved.
//

import UIKit 
import MobileCoreServices

private let kDefaultCoverUrl = "static.sendbird.com/sample/cover"
private let kDefaultGroupChannelName = "Group Channel"
private let kDefaultOpenChannelName = "Open Channel"

@objcMembers
public class SBUUtils: NSObject {
    
    /// This function gets the message file type of the file message.
    /// - Parameter fileMessage: `SBDFileMessage` object
    /// - Returns: `MessageFileType`
    @objc(getFileTypeByFileMessage:)
    public static func getFileType(by fileMessage: SBDFileMessage) -> MessageFileType {
        return getFileType(by: fileMessage.type)
    }
    
    /// This function gets the message file type string as the type.
    /// - Parameter type: File type string
    /// - Returns: `MessageFileType`
    @objc(getFileTypeByType:)
    public static func getFileType(by type: String) -> MessageFileType {
        let type = type.lowercased()
        
        if type.hasPrefix("image") {
            if type.contains("svg") { return .etc }
            else { return .image }
        }
        if type.hasPrefix("video") { return .video }
        if type.hasPrefix("audio") { return .audio }
        if type.hasPrefix("pdf")   { return .pdf }
        
        return .etc
    }
    
    /// This is a function that creates a channel name.
    ///
    ///  If the channel name is not entered after creating the channel or channel name is empty,
    ///  the channel name is generated by combining the nicknames of the members in the channel.
    ///
    /// - Parameter channel: `SBDGroupChannel` object
    /// - Returns: Generated channel name
    public static func generateChannelName(channel: SBDGroupChannel) -> String {
        guard !SBUUtils.isValid(channelName: channel.name) else {
            return channel.name
        }
        guard let members = channel.members as? [SBDUser] else { return channel.name }
        let users = members
            .sbu_convertUserList()
            .filter { $0.userId != SBUGlobals.CurrentUser?.userId }

        guard users.count != 0 else { return SBUStringSet.Channel_Name_No_Members}
        let userNicknames = users.sbu_getUserNicknames()
        let channelName = userNicknames.joined(separator: ", ")

        return channelName
    }
    
    
    /// This function gets the MIME type from the URL.
    /// - Parameter url: url
    /// - Returns: MIME type string
    public static func getMimeType(url: URL) -> String? {
        let lastPathComponent = url.lastPathComponent
        let ext = (lastPathComponent as NSString).pathExtension
        guard let UTI = UTTypeCreatePreferredIdentifierForTag(
            kUTTagClassFilenameExtension, ext as CFString, nil)?
            .takeRetainedValue() else { return nil }
        guard let retainedValueMimeType = UTTypeCopyPreferredTagWithClass(
            UTI, kUTTagClassMIMEType)?
            .takeRetainedValue() else { return nil }
        let mimeType = retainedValueMimeType as String
        
        return mimeType
    }
    
    /// This function gets the receipt state of the message on the channel.
    /// - Parameters:
    ///   - channel: `SBDGroupChannel` object
    ///   - message: `SBDBaseMessage` object
    /// - Returns: `SBUMessageReceiptState`
    @available(*, deprecated, message: "deprecated in 2.0.5", renamed: "getReceiptStateIfExists")
    public static func getReceiptState(channel: SBDGroupChannel,
                                       message: SBDBaseMessage) -> SBUMessageReceiptState {
        let didReadAll = channel.getUnreadMemberCount(message) == 0
        let didDeliverAll = channel.getUndeliveredMemberCount(message) == 0
        
        if didReadAll {
            return .readReceipt
        } else if didDeliverAll {
            return .deliveryReceipt
        } else {
            return .none
        }
    }
    
    /// This function gets the receipt state of the message on the channel.
    /// Will return nil for `Super Group Channel` or `Broadcast Channel` which  doesn't support receipts.
    ///
    /// - Parameters:
    ///   - channel: `SBDGroupChannel` object
    ///   - message: `SBDBaseMessage` object
    /// - Returns: `SBUMessageReceiptState`, or nil if the channel doesn't support receipts.
    public static func getReceiptStateIfExists(for channel: SBDGroupChannel,
                                               message: SBDBaseMessage) -> SBUMessageReceiptState? {
        guard !channel.isSuper
            && !channel.isBroadcast else { return nil }
        
        let didReadAll = channel.getUnreadMemberCount(message) == 0
        let didDeliverAll = channel.getUndeliveredMemberCount(message) == 0
        
        if didReadAll {
            return .readReceipt
        } else if didDeliverAll {
            return .deliveryReceipt
        } else {
            return SBUMessageReceiptState.none
        }
    }
    
    /// This function checks the validity of coverUrl.
    /// - Parameter coverUrl: Cover url string
    /// - Returns: If corverUrl is valid, return `true`.
    public static func isValid(coverUrl: String) -> Bool {
        guard !coverUrl.hasPrefix(SBUConstant.coverImagePrefix),
            coverUrl.count != 0  else {
                return false
        }
        
        return true
    }
    
    /// This function checks the validity of channel name.
    /// - Parameter channelName: Channel name string
    /// - Parameter type: Channel type
    /// - Returns: If channel name is valid, return `true`.
    public static func isValid(channelName: String, type: ChannelType = .group) -> Bool {
        var prefixString = kDefaultGroupChannelName
        
        if type == .open {
            prefixString = kDefaultOpenChannelName
        }
        
        guard !channelName.hasPrefix(prefixString),
            channelName.count != 0  else {
                return false
        }
        
        return true
    }
    
    public static func emptyTitleForRowEditAction(for size: CGSize) -> String {
        let placeholderSymbol = "\u{200A}"
        let minimalActionWidth: CGFloat = 30
        let shiftFactor: CGFloat = 1.1

        let flt_max = CGFloat.greatestFiniteMagnitude
        let maxSize = CGSize(width: flt_max, height: flt_max)
        let attributes = [
            NSAttributedString.Key.font : UIFont.systemFont(ofSize: UIFont.systemFontSize)
        ]
        let boundingRect = placeholderSymbol.boundingRect(
            with: maxSize,
            options: .usesLineFragmentOrigin,
            attributes: attributes,
            context: nil
        )
        
        var usefulWidth = size.width - minimalActionWidth
        usefulWidth = usefulWidth < 0 ? 0 : usefulWidth
        let countOfSymbols = Int(floor(usefulWidth * shiftFactor / boundingRect.width))
        return String(repeating: placeholderSymbol, count: countOfSymbols)
    }
}

extension SBUUtils {

    // To dismiss presented views which should be dismissed on view disappear.
    // - `SBUEmojiListViewController`
    // - `SBUReactionsViewController`
    // - `SBUMenuViewController`
    static func dismissPresentedOnDisappear(presentedViewController: UIViewController?) {
        guard let presented = presentedViewController else { return }
        
        if presented is SBUEmojiListViewController ||
            presented is SBUReactionsViewController ||
            presented is SBUMenuViewController {
            presented.dismiss(animated: false, completion: nil)
        }
    }
    
    static func findIndex(of message: SBDBaseMessage, in messageList: [SBDBaseMessage]) -> Int? {
        return messageList.firstIndex(where: { $0.messageId == message.messageId })
    }
    
    static func contains(messageId: Int64, in messageList: [SBDBaseMessage]) -> Bool {
        return messageList.contains(where: { $0.messageId == messageId })
    }
}
